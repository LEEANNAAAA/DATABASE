--1 갯수 세기-COUNT()
SELECT COUNT(*)
FROM EMP;

--2 부서번호 별 봉급 합계 > GROUP BY 를 빼면 오류
SELECT DEPTNO,SUM(SAL)
FROM EMP 
GROUP BY DEPTNO;

--3 부서번호 출력
SELECT DEPTNO
FROM EMP;

SELECT DISTINCT DEPTNO
FROM EMP;

--4 사원들이 속한 부서의 수
SELECT COUNT(DISTINCT DEPTNO)
FROM EMP;

--5 급여 합계(DISTINCT와 ALL사용) > ALL은 쓰나마나
SELECT SUM(DISTINCT SAL),
      SUM(ALL SAL),
      SUM(SAL)
FROM EMP;

--6 사원들의 정보
SELECT *
FROM EMP;

--7 사원들의 수 (행의 수)
SELECT COUNT(*)
FROM EMP;

--8 30번 부서의 사원 수
SELECT COUNT(*)
FROM EMP
WHERE DEPTNO=30;

--9 봉급의 개수
SELECT COUNT(DISTINCT SAL),
      COUNT(ALL SAL),
      COUNT(SAL)
FROM EMP;

--10 보너스가 정해진 사람들의 수
SELECT  COUNT(COMM)
FROM EMP;

--11 보너스 받는 사람 수
SELECT COUNT(COMM)
FROM EMP
WHERE COMM>0;

--12 보너스가 NULL이 아닌 사람(정해진 사람) / *이나 COMM이나 상관없음 행을 세는거기 때문에
SELECT COUNT(*)
FROM EMP
WHERE COMM IS NOT NULL;

--13 봉급의 최대치
SELECT MAX(SAL)
FROM EMP;

--14 10번 부서의 최고 봉급액
SELECT MAX(SAL)
FROM EMP
WHERE DEPTNO=10;

--15 10번 부서의 최저 봉급액
SELECT MIN(SAL)
FROM EMP
WHERE DEPTNO=10;

--16 10번 부서의 최저 평균 봉급액
SELECT AVG(SAL)
FROM EMP
WHERE DEPTNO=10;

--17 최근 입사일
SELECT MAX(HIREDATE)
FROM EMP;

--18 가장 먼저 입사한 사원의 입사일
SELECT MIN(HIREDATE)
FROM EMP;

--19 20번 부서에서 최고참의 입사일
SELECT MIN(HIREDATE)
FROM EMP
WHERE DEPTNO=20;

--20 30번 부서의 평균 봉급액
SELECT AVG(SAL)
FROM EMP
WHERE DEPTNO = 30;
 
--21 10번 부서, 20번 부서, 30번 부서의 평균 봉급액 구하기 > , ' '를 찍어달라고 한 것
SELECT TRUNC(AVG(SAL)) AS AVG_SAL, '10' AS DEPTNO FROM EMP WHERE DEPTNO=10
UNION ALL
SELECT TRUNC(AVG(SAL)) AS AVG_SAL, '20' AS DEPTNO FROM EMP WHERE DEPTNO=20
UNION ALL
SELECT TRUNC(AVG(SAL)) AS AVG_SAL, '30' AS DEPTNO FROM EMP WHERE DEPTNO=30;

--22 부서 빛 직급별 평균 봉급
SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO;

--23 부서 빛 직급별 평균 봉급을 구하는데 봉급 평균이 2000이상인 사원들 정보만
SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL)>=2000
ORDER BY DEPTNO;

--24 봉급이 3000이하인 사람들 대상 부서별, 직급별 평균 봉급이 2000이상
SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
WHERE SAL <=3000
GROUP BY DEPTNO, JOB
HAVING AVG(SAL)>=2000
ORDER BY DEPTNO, JOB;

--25 부서별 직급별, 사원수, 최대 봉급, 봉급액 합계, 평균 봉급, 부서별 직급별 정렬
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

--26 25번과 동일 + ROLLUP(DEPTNO, JOB)요약
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--27 CUBE 사용
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), ROUND(AVG(SAL))
FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--28 ROLLUP을 JOB에 대해서반 부서, 직급별 인원수
SELECT DEPTNO, JOB, COUNT(*)
FROM EMP
GROUP BY DEPTNO, ROLLUP(JOB);

--29 ROLLUP을 DEPTNO에 대해서반 부서, 직급별 인원수
SELECT DEPTNO, JOB, COUNT(*)
FROM EMP
GROUP BY JOB, ROLLUP(DEPTNO);

--30 GROUPING SETS > 지정한 모든 열을 대그룹으로 처리해서 출력
SELECT DEPTNO, JOB, COUNT(*)
FROM EMP
GROUP BY GROUPING SETS(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--31 GROUPING 함수
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), ROUND(AVG(SAL)),
      GROUPING(DEPTNO),
      GROUPING(JOB)
FROM EMP
GROUP BY CUBE(DEPTNO,JOB)
ORDER BY DEPTNO, JOB;

--32 DECODE > 어느 함수가 1인경우 ' '로 표시한다
SELECT DECODE(GROUPING(DEPTNO),1,'ALL_DEPTNO',DEPTNO) AS DEPTNO,
      DECODE(GROUPING(JOB), 1, 'ALL_JOB', JOB) AS JOB,
       COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--33 GROUPING_ID > 그룹화 여부를 확인할 열
SELECT DEPTNO, JOB, COUNT(*), SUM(SAL),
     GROUPING(DEPTNO),
     GROUPING(JOB),
     GROUPING_ID(DEPTNO, JOB)
FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--34 LISTAGG > 가로로 나열
SELECT DEPTNO,
      LISTAGG(ENAME, ', ')
      WITHIN GROUP(ORDER BY HIREDATE ASC) AS ENAMES
 FROM EMP
GROUP BY DEPTNO;

--35 부서별, 직급별로 그룹화하여 최고 급여 데이터 출력
SELECT DEPTNO, JOB, MAX(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

--36 PIVOT함수를 사용하여 직책별, 부서별 최고 급여 2차원 표 형태로 출력 > MAX(SAL)를 FOR 부서별 IN 목록
SELECT *
FROM(SELECT DEPTNO, JOB, SAL FROM EMP)
PIVOT(MAX(SAL) FOR DEPTNO IN (10, 20, 30))
ORDER BY JOB;

--37 PIVOT함수를 사용하여 부서별, 직책별 최고 급여를 2차원 표 형태로 출력 > ''가 안나오게 하기 위해서 별칭 사용
SELECT *
FROM(SELECT JOB, DEPTNO, SAL FROM EMP)
PIVOT(MAX(SAL) FOR JOB IN ('CLERK' AS CLERK,
                 'SALESMAN' AS SALESMAN,
                 'PRESIDENT' AS PRESIDENT,
                 'MANAGER' AS MANAGER,
                 'ANALYST' AS ANALYST))
ORDER BY DEPTNO;

--38 DECODE문을 활용하여 PIVOT 함수와 같은 출력 구현 / 별칭의 경우 ""해도되고 안해도 됨
SELECT DEPTNO,
     MAX(DECODE(JOB, 'CLERK', SAL)) AS CLERK,
     MAX(DECODE(JOB, 'SALESMAN', SAL)) AS "SALESMAN",
     MAX(DECODE(JOB, 'PRESIDENT', SAL)) AS "PRESIDENT",
     MAX(DECODE(JOB, 'MANAGER', SAL)) AS "MANAGER",
     MAX(DECODE(JOB, 'ANALYST', SAL)) AS "ANALYST"
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;

--39 UNPIVOT > PIVOT의 반대방향(세로)
SELECT *
FROM(SELECT DEPTNO,
       MAX(DECODE(JOB, 'CLERK' , SAL)) AS "CLERK",
       MAX(DECODE(JOB, 'SALESMAN' , SAL)) AS "SALESMAN",
       MAX(DECODE(JOB, 'PRESIDENT', SAL)) AS "PRESIDENT",
       MAX(DECODE(JOB, 'MANAGER' , SAL)) AS "MANAGER",
       MAX(DECODE(JOB, 'ANALYST' , SAL)) AS "ANALYST"
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO)
UNPIVOT(SAL FOR JOB IN (CLERK, SALESMAN, PRESIDENT, MANAGER,ANALYST))
ORDER BY DEPTNO, JOB;

--Q-1
SELECT DEPTNO, TRUNC(AVG(SAL))AS AVG_SAL,TRUNC( MAX(SAL))AS MAX_SAL, MIN(SAL)AS MIN_SAL, COUNT(*) AS CNT
FROM EMP
GROUP BY DEPTNO;

--Q-2
SELECT JOB, COUNT(*)
FROM EMP
GROUP BY JOB
HAVING COUNT(*)>=3;

--Q-3
SELECT TO_CHAR(HIREDATE, 'YYYY') AS HIRE_YEAR, DEPTNO, COUNT(*) AS CNT
FROM EMP
GROUP BY DEPTNO, TO_CHAR(HIREDATE,'YYYY');

--Q-4
SELECT NVL2(COMM,'O','X') AS EXIST_COMM,COUNT(*) AS CNT
FROM EMP
GROUP BY NVL2(COMM,'O','X');

--Q-5
SELECT DEPTNO, 
      TO_CHAR(HIREDATE,'YYYY') AS HIRE_YEAR, 
      COUNT(*) AS CNT, 
      MAX(SAL) AS MAX_SAL, 
      SUM(SAL) AS SUM_SAM, 
      AVG(SAL) AS AVG_SAL
FROM EMP
GROUP BY ROLLUP(DEPTNO, TO_CHAR(HIREDATE,'YYYY'));