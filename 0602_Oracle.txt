SELECT *
FROM EMP;

--1 
select *
from emp
where sal between 2000 and 3000;

--2 
select sal, COMM,SAL*12+NVL(COMM,0) AS "연 봉"      --COMM 값이 NULL 이면 0으로 표시해서 계산
from EMP;

select sal, COMM,NVL2(COMM, SAL*12+COMM, SAL*12) AS "연 봉"      -- 연봉 사이를 띄어주려먼 ""사용
from EMP;

--3
SELECT EMPNO, ENAME, JOB,SAL,
  DECODE(JOB,   --DECODE > 조건을 줌
     'MANAGER',SAL*1.1,
     'SALESMAN',SAL*1.05,
     'ANALYST',SAL,
      SAL*1.03) AS UPSAL
  FROM EMP;
  
 --4
 SELECT EMPNO,ENAME, JOB,SAL,
  CASE JOB    --DECODE 함수보다 더 프로그래밍 언어적인 표현 방식을 사용(WHEN THEN ELSE END)
     WHEN 'MANAGER' THEN SAL*1.1
     WHEN 'SALESMAN'THEN SAL*1.05
     WHEN 'ANALYST' THEN SAL
     ELSE SAL*1.03
    END AS UPSAL
FROM EMP;

--5
SELECT EMPNO, ENAME, COMM,
  CASE 
    WHEN COMM IS NULL THEN '해당사항없음' --=NULL이라고 쓰면 안됨
    WHEN COMM =0 THEN '수당없음'
    WHEN COMM >0 THEN '수당:'||COMM
  END AS COMM_TEXT
FROM EMP;

--6장 연습문제
--6-1
SELECT EMPNO, 
RPAD(SUBSTR(EMPNO,1,2),4,'*')AS MASKING_EMPNO,    --EMPNO 첫째자리부터 2글자만 추출하여 오른쪽에 *로 나머지자리 채워줌
ENAME,
RPAD(SUBSTR(ENAME,1,1),5,'*')AS MASKING_ENAME
FROM EMP
WHERE LENGTH(ENAME)=5;
      
--6-2
SELECT EMPNO, ENAME, SAL, 
  TRUNC(SAL/21.5,2)AS DAY_PAY,    --TRUNC 나머지 자리 버림
  ROUND(SAL/21.5/8,1)AS TIME_PAY    --ROUND 반올림, 첫째자리까지만 출력
FROM EMP;

--6-3
SELECT EMPNO, ENAME, HIREDATE,
    TO_CHAR(NEXT_DAY(ADD_MONTHS(HIREDATE,3),'월요일'),'YYYY-MM-DD')AS R_JOB,   --다음주 돌아오는 월요일 > NEXT_DAY, 문자로 바꿔줘야 하므로 TO_CHAR
    NVL(TO_CHAR(COMM),'N/A')AS COMM   --숫자를 문자로 바꿔준 후 적용
FROM EMP;

--6-4
SELECT EMPNO, ENAME, MGR,
  CASE
    WHEN MGR IS NULL THEN '0000'    --문자로 적용
    WHEN SUBSTR(MGR,1,2)='75' THEN '5555'
    WHEN SUBSTR(MGR,1,2)='76' THEN '6666'
    WHEN SUBSTR(MGR,1,2)='77' THEN '7777'
    WHEN SUBSTR(MGR,1,2)='78' THEN '8888'
    ELSE TO_CHAR(MGR)   -- 이 부분 주의
  END AS CHG_MGR
FROM EMP;



--7-1
SELECT SUM(SAL), COUNT(SAL),MAX(SAL),MIN(SAL), AVG(SAL)
FROM EMP;

--7-2 사원 수(ENAME 대신에 *로 만들어도 무방)
SELECT COUNT(ENAME)
FROM EMP;

--7-3부서의 수
SELECT * FROM DEPT;

SELECT COUNT(*)
FROM DEPT;

--7-4 보너스 없는 사원의 수
SELECT COUNT(*)
FROM EMP
WHERE COMM IS NULL;

--7-5 10번 부서의 사원수 (*는 NULL값도 COUNT한다. *이 안정적)
SELECT COUNT(*)
FROM EMP
WHERE DEPTNO = 10;

--7-6 각 부서별 사원 수
SELECT DEPTNO, COUNT(*)
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO ASC;

--7-7 각 부서별 최고 봉급
SELECT DEPTNO, MAX(SAL)
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;

--7-8 각 부서별 최장기간 근무한 사람의 입사일
SELECT DEPTNO, MIN(HIREDATE)    --날짜가 훨씬 이전이기 때문에 MIN 으로 해줌
FROM EMP
GROUP BY DEPTNO;

--7-9
SELECT DEPTNO
FROM EMP;
--7-10
SELECT DISTINCT DEPTNO    --distinct : 중복제거
FROM EMP;
--7-11
SELECT SUM(SAL), SUM(ALL SAL), SUM(DISTINCT SAL)
FROM EMP;

--7-12 입사일 출력, 단, 중복제거
SELECT DISTINCT HIREDATE
FROM EMP;

--7-13 30번 부서의 인원 수
SELECT DEPTNO, COUNT(*)
FROM EMP
WHERE DEPTNO=30;

--7-14 10번 부서의 최고 봉급액
SELECT MAX(SAL)
FROM EMP
WHERE DEPTNO=10;

--7-15 10번 부서 최저 봉급액
SELECT MIN(SAL)
FROM EMP
WHERE DEPTNO=10;

--7-16 20번 부서의 최근 입사자의 입사일
SELECT MAX(HIREDATE)
FROM EMP
WHERE DEPTNO=20;

--7-17 20번 부서의 최고 장기간 근무한 사람의 입사일
SELECT MIN(HIREDATE)
FROM EMP
WHERE DEPTNO=20;

--7-18 30번 부서의 평균 봉급
SELECT AVG(SAL)
FROM EMP
WHERE DEPTNO = 30;

--7-19 30번 부서의 평균 봉급(단, 봉급의 중복은 제거 후 평균)
SELECT AVG(DISTINCT SAL)
FROM EMP
WHERE DEPTNO=30;

--7-20 부서번호가 10,20,30인 평균 봉급
SELECT ROUND(AVG(SAL)), '10'AS DEPTNO FROM EMP WHERE DEPTNO = 10
UNION ALL
SELECT ROUND(AVG(SAL)), '20'AS DEPTNO FROM EMP WHERE DEPTNO = 20
UNION ALL
SELECT ROUND(AVG(SAL)), '30'AS DEPTNO FROM EMP WHERE DEPTNO = 30;

--7-21 부서번호, 직급별 평균 봉급
SELECT DEPTNO, jOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

--7-22 부서와 직급별로 평균 봉급이 2000이상인 사원들의 부서번호, 직급, 평균 봉급 / 부서번호, 직급 순으로 출력
SELECT DEPTNO, JOB,AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL)>=2000   --그룹별 조건
ORDER BY DEPTNO, JOB;   --정렬 순서

--7-23  WHERE 절 자체에는 그룹함수를 사용할 수 없다!! > 오류
SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
WHERE AVG(SAL)>=2000
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

--7-24 봉급이 3000이하인 사원들을 대상으로 부서, 직급별 평균 봉급이 2000이상인 
SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
WHERE SAL<=3000 
GROUP BY DEPTNO, JOB
HAVING AVG(SAL)>=2000 --WHERE 절로 가면 안됨
ORDER BY DEPTNO, JOB;

--7-25 부서, 직급별 사원수,최대 봉급, 봉급 합계, 평균 봉급 출력
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB; 

--ROLLUP
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB)  --ROLLUP : 소그룹간의 소계를 나타냄
ORDER BY DEPTNO, JOB;

--7-26 CUBE
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
FROM EMP
GROUP BY CUBE(DEPTNO, JOB)  --CUBE : GROUP BY절에 있는 모든 컬럼들에 대한 가능한 모든 조합을 그룹으로 생성
ORDER BY DEPTNO, JOB;

--7-27
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
FROM EMP
GROUP BY DEPTNO,ROLLUP(JOB);

--7-28
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
FROM EMP
GROUP BY  JOB, ROLLUP(DEPTNO);

--7-29
SELECT DEPTNO, JOB, COUNT(*)
FROM EMP
GROUP BY GROUPING SETS(DEPTNO, JOB) --GROUPING SETS : 지정한 각 열별 그룹화
ORDER BY DEPTNO, JOB;

--7-30
SELECT DEPTNO, JOB,COUNT(*)
FROM EMP
GROUP BY ROLLUP(JOB,DEPTNO); --2개를 집어넣으면 그 두개에 대한 COUNT도 출력

--7-31
SELECT DEPTNO, JOB, COUNT(*)
FROM EMP
GROUP BY GROUPING SETS(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--7-32
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL),
       GROUPING(DEPTNO),
       GROUPING(JOB)
  FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--7-33 여기서 1은 그룹핑 안되었을 경우를 뜻함(0은 그룹핑 되어있는 상태)
SELECT DECODE(GROUPING(DEPTNO), 1, 'ALL_DEPT', DEPTNO) AS DEPTNO,
       DECODE(GROUPING(JOB), 1, 'ALL_JOB', JOB) AS JOB,
       COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
  FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;